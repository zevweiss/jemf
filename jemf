#!/usr/bin/python

# jemf: a jeneric (?), encrypted mini-filesystem
#
# (a command-line password manager).
#
# Stores data in a gpg-encrypted JSON file.

import sys
import argparse
import getpass
import subprocess
import json
import os
import os.path
import random

default_fspaths = [os.path.expanduser(p) for p in ["~/.config/jemf", "~/.jemf"]]
gpgcmd = "gpg"

# compat
if hasattr(os, "pipe2"):
	pipe = lambda: os.pipe2(0)
else:
	pipe = os.pipe

class CorruptFS(Exception):
	pass

class MistypedObject(CorruptFS):
	def __init__(self, path, obj):
		msg = "Mistyped object '%s': %s" % (path, str(type(obj)))
		super(MistypedObject, self).__init__(msg)
		self.wrongtype = type(obj)
		self.path = path

def error(msg):
	sys.stderr.write("Error: %s\n" % msg)
	exit(1)

def confirmed_getpass(label):
	pass1 = getpass.getpass("Enter %s: " % label)
	pass2 = getpass.getpass("Confirm %s: " % label)
	if pass1 != pass2:
		error("input mismatch")
	else:
		return pass1

def find_fs():
	for p in default_fspaths:
		if os.path.exists(p):
			return p
	return None

UNKNOWN = 0
FILE = 1
DIRECTORY = 2
def fsobjtype(obj):
	if type(obj) == dict:
		return DIRECTORY
	elif type(obj) == str or type(obj) == unicode:
		return FILE
	else:
		return UNKNOWN

def run_gpg(args, passwd, stdin_data=None):
	pw_r, pw_w = pipe()
	pw_w = os.fdopen(pw_w, "w")
	cmdargs = [gpgcmd, "--quiet", "--batch", "--passphrase-fd", str(pw_r)] + args

	# close write end of passphrase pipe in child process
	proc = subprocess.Popen(cmdargs, stdout=subprocess.PIPE, stdin=subprocess.PIPE,
				close_fds=False, preexec_fn=lambda: pw_w.close())

	# parent doesn't use read end
	os.close(pw_r)

	# send passphrase to gpg child
	pw_w.write(passwd)
	# probably redundant, since we're just about to close it, but why not...
	pw_w.flush()
	pw_w.close()

	stdout_data, _ = proc.communicate(stdin_data)

	retval = proc.wait()
	if retval != 0:
		raise subprocess.CalledProcessError(retval, cmdargs)

	return stdout_data

def load_jemf_fs(filename, passwd):
	s = run_gpg(["-d", "--no-mdc-warning", filename], passwd)
	return json.loads(s.decode("utf-8"))

def store_jemf_fs(fsd, filename, passwd):
	jfs = json.dumps(fsd)
	# TODO: output to temp file, rename over existing?
	output = run_gpg(["-c", "--yes", "-o", filename], passwd, jfs)
	if output != "":
		error("Unexpected output from gpg: %s\n" % output)

def open_jemf_fs(path):
	passwd = getpass.getpass("Enter password for %s: " % path)
	return load_jemf_fs(path, passwd), passwd

def path_components(path):
	np = os.path.normpath(path)
	while len(np) > 0 and np[0] == os.sep:
		np = np[1:]
	return np.split(os.sep) if len(np) > 0 else []

def lookup_comps(fsd, comps):
	fsdir = fsd
	trail = os.sep
	for c in comps:
		try:
			fsdir = fsdir[c]
		except KeyError:
			error("'%s' does not exist in '%s'" % (c, trail))
		trail = os.path.join(trail, c)
	return fsdir

def lookup_path(fsd, path):
	return lookup_comps(fsd, path_components(path))

def lookup_for_edit(fsd, path, should_exist):
	"""Lookup the parent of 'path' in 'fsd', returning a tuple of it and
	the last component of 'path'."""
	comps = path_components(path)
	parentcomps = comps[:-1]
	tgtcomp = comps[-1]
	parent = lookup_comps(fsd, parentcomps)
	if fsobjtype(parent) != DIRECTORY:
		error("'%s' is not a directory")
	elif not should_exist and tgtcomp in parent:
		error("'%s' already exists" % path)
	elif should_exist and tgtcomp not in parent:
		error("'%s' does not exist" % path)
	return (parent, tgtcomp)

default_constraints = "L12:C2:m2:N2:P2"

gen_constraints_desc = """
CONSTRAINTS is a colon-separated list of data constraints of the form TV.

T is a type indicator: L for length, C for capital letters, m for
lower-case letters, N for numerals (digits), and P for punctuation
characters.

V is the numeric value of of the constraint: for L (length) this
specifies the length of the generated data; for all others it provides
a minimum number of characters of that type, though as a special case
V=0 means the character type will be omitted.

The default constraint is %s, specifying a twelve-character
entry with at least two capital letters, at least two lower-case
letters, at least two digits, and at least two punctuation characters.

Stupid-site example: L8:C2:m2:N2:P0 for an 8-character purely
alphanumeric (but mixed-case) entry.""" % default_constraints

def constraints_to_dict(cstr):
	d = {}
	for c in cstr.split(":"):
		if c != "":
			d[c[0]] = int(c[1:])
	return d

uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
lowers = "abcdefghijklmnopqrstuvwxyz"
digits = "0123456789"
punctuation = "!@#$%^&*:._-=+"

def generate_data(constraints):
	cdict = constraints_to_dict(default_constraints)
	cdict.update(constraints_to_dict(constraints))
	s = ""
	for _ in xrange(0, cdict['C']):
		s += random.choice(uppers)
	for _ in xrange(0, cdict['m']):
		s += random.choice(lowers)
	for _ in xrange(0, cdict['N']):
		s += random.choice(digits)
	for _ in xrange(0, cdict['P']):
		s += random.choice(punctuation)

	padchars = ""
	if cdict['C'] > 0:
		padchars += uppers
	if cdict['m'] > 0:
		padchars += lowers
	if cdict['N'] > 0:
		padchars += digits
	if cdict['P'] > 0:
		padchars += punctuation

	# fill remaining space from pad character sets
	for _ in xrange(0, cdict['L']-len(s)):
		s += random.choice(padchars)

	l = list(s)
	random.shuffle(l)
	return ''.join(l[:cdict['L']])

def mkfs(args, unused_fsd, unused_passwd):
	if os.path.exists(args.fsfile) and not args.force:
		error("%s exists (use -f to force reinitialization)" % args.fsfile)
	passwd = confirmed_getpass("password for new jemf FS (%s)" % args.fsfile)
	store_jemf_fs({}, args.fsfile, passwd)

def mkdir(args, fsd, passwd):
	parent, newname = lookup_for_edit(fsd, args.path, should_exist=False)
	parent[newname] = {}
	store_jemf_fs(fsd, args.fsfile, passwd)

def create(args, fsd, passwd):
	parent, newname = lookup_for_edit(fsd, args.path, should_exist=False)
	if args.generate is None:
		parent[newname] = confirmed_getpass("data for %s" % args.path)
	else:
		parent[newname] = generate_data(args.generate)
	store_jemf_fs(fsd, args.fsfile, passwd)

def edit(args, fsd, passwd):
	parent, tgtname = lookup_for_edit(fsd, args.path, should_exist=True)
	if fsobjtype(parent[tgtname]) != FILE:
		error("'%s' is not a file" % args.path)

	if args.generate is None:
		parent[tgtname] = confirmed_getpass("new data for %s" % args.path)
	else:
		parent[tgtname] = generate_data(args.generate)
	store_jemf_fs(fsd, args.fsfile, passwd)

def rm(args, fsd, passwd):
	parent, tgtname = lookup_for_edit(fsd, args.path, should_exist=True)
	if args.recursive:
		del parent[tgtname]
	else:
		obj = parent[tgtname]
		if fsobjtype(obj) == DIRECTORY and len(obj) > 0:
			error("'%s' is not empty" % args.path)
		else:
			del parent[tgtname]

	store_jemf_fs(fsd, args.fsfile, passwd)

def cat(args, fsd, unused_passwd):
	item = lookup_path(fsd, args.path)
	t = fsobjtype(item)
	if t == DIRECTORY:
		error("'%s' is a directory" % args.path)
	elif t != FILE:
		raise MistypedObject(args.path, item)
	sys.stdout.write(item + '\n')

def recursive_list(obj, pfx):
	t = fsobjtype(obj)
	if t == FILE or t == DIRECTORY:
		sys.stdout.write("%s\n" % pfx)
		if t == DIRECTORY:
			for n, o in obj.items():
				recursive_list(o, os.path.join(pfx, n))
	else:
		raise MistypedObject(pfx, obj)

def find(args, fsd, unused_passwd):
	if args.path is None:
		recursive_list(fsd, "/")
	else:
		recursive_list(lookup_path(fsd, args.path), args.path)

def ls(args, fsd, unused_passwd):
	if args.path is not None:
		obj = lookup_path(fsd, args.path)
	else:
		obj = fsd

	if fsobjtype(obj) == FILE:
		sys.stdout.write(args.path + '\n')
	elif fsobjtype(obj) == DIRECTORY:
		for n, o in obj.items():
			sys.stdout.write("%s%s\n" % (n, "/" if fsobjtype(o) == DIRECTORY else ""))
	else:
		raise MistypedObject(args.path, obj)

def dump(args, fsd, unused_passwd):
	sys.stdout.write(json.dumps(fsd, sort_keys=True, indent=4) + '\n')

if __name__ == "__main__":
	mainparser = argparse.ArgumentParser(description="a jeneric (?), encrypted mini-filesystem")

	mainparser.add_argument("-f", "--fsfile", type=str, help="jemf FS file to use")

	subparsers = mainparser.add_subparsers()
	def subcommand(action, *args, **kwargs):
		parser = subparsers.add_parser(*args, **kwargs)
		parser.set_defaults(action=action)
		return parser

	mkfs_parser = subcommand(mkfs, "mkfs", help="initialize a jemf FS")
	mkfs_parser.add_argument("-f", "--force", action="store_true")

	mkdir_parser = subcommand(mkdir, "mkdir", help="create a new directory")

	cat_parser = subcommand(cat, "cat", help="print a file to stdout")

	create_parser = subcommand(create, "create", help="create a new file",
				   epilog=gen_constraints_desc,
				   formatter_class=argparse.RawDescriptionHelpFormatter)

	edit_parser = subcommand(edit, "edit", help="edit an existing file",
				 epilog=gen_constraints_desc,
				 formatter_class=argparse.RawDescriptionHelpFormatter)

	rm_parser = subcommand(rm ,"rm", help="delete a file or directory")
	rm_parser.add_argument("-r", "--recursive", action="store_true",
			       help="delete directories recursively")

	find_parser = subcommand(find, "find", help="recursively list files and directories")

	ls_parser = subcommand(ls, "ls", help="list files and directories")

	dump_parser = subcommand(dump, "dump", help="dump plaintext JSON")

	# Commands that require a path
	for p in [mkdir_parser, cat_parser, create_parser, edit_parser, rm_parser]:
		p.add_argument("path", metavar="PATH")

	# Commands that take an optional path
	for p in [find_parser, ls_parser]:
		p.add_argument("path", metavar="PATH", nargs='?')

	# Commands that allow automatic data generation
	for p in [create_parser, edit_parser]:
		p.add_argument("-g", "--generate", metavar="CONSTRAINTS", nargs='?',
			       help="auto-generate random entry data",
			       type=str, default=default_constraints)

	args = mainparser.parse_args()

	if args.fsfile is None:
		args.fsfile = find_fs()

	if args.fsfile is None:
		if args.action != mkfs:
			error("No jemf FS found or specified")
		else:
			args.fsfile = default_fspaths[0]

	try:
		if args.action != mkfs:
			fsd, passwd = open_jemf_fs(args.fsfile)
		else:
			fsd, passwd = None, None
		args.action(args, fsd, passwd)

	except subprocess.CalledProcessError as cpe:
		cmdname = cpe.cmd[0] if type(cpe.cmd) is list else cpe.cmd.split()[0]
		sys.stderr.write("%s exited with status %d\n" % (cmdname, cpe.returncode))
		exit(1)
