#!/usr/bin/python

# jemf: a jeneric (?), encrypted mini-filesystem
#
# (a command-line password manager).
#
# Stores data in a gpg-encrypted JSON file.

from __future__ import print_function

import sys
import argparse
import getpass
import subprocess
import json
import os
import os.path
import random
import socket
import time
import tempfile
from cmd import Cmd as CommandInterpreter
import shlex

try:
	import readline
	import string
	readline.set_completer_delims(string.whitespace + os.sep)
except ImportError:
	pass

default_fspaths = [os.path.expanduser(p) for p in ["~/.config/jemf", "~/.jemf"]]
gpgcmd = "gpg"

# Python 2/3 compat stuff
if hasattr(os, "pipe2"):
	pipe = lambda: os.pipe2(0)
else:
	pipe = os.pipe

try:
	unicode
	strtypes = (str, unicode)
except NameError:
	strtypes = (str,)

class UserError(Exception):
	pass

class UsageError(UserError):
	pass

class InternalError(Exception):
	pass

class CorruptFS(Exception):
	pass

class MistypedObject(CorruptFS):
	def __init__(self, path, obj):
		msg = "Mistyped object '%s': %s" % (path, str(type(obj)))
		super(MistypedObject, self).__init__(msg)
		self.wrongtype = type(obj)
		self.path = path

def errprint(*args, **kwargs):
	print(*args, file=sys.stderr, **kwargs)

def error(msg):
	raise UserError("Error: %s" % msg)

def internal_error(msg):
	raise InternalError("Internal error: %s" % msg)

def confirmed_getpass(label):
	pass1 = getpass.getpass("Enter %s: " % label)
	pass2 = getpass.getpass("Confirm %s: " % label)
	if pass1 != pass2:
		error("input mismatch")
	else:
		return pass1

def find_fs():
	for p in default_fspaths:
		if os.path.exists(p):
			return p
	return None

UNKNOWN = 0
FILE = 1
DIRECTORY = 2
def fsobjtype(obj):
	if isinstance(obj, dict):
		return DIRECTORY
	elif isinstance(obj, strtypes):
		return FILE
	else:
		return UNKNOWN

def pretty_json_dump(d):
	return json.dumps(d, sort_keys=True, indent=4, separators=(',', ': ')) + '\n'

def run_gpg(args, passwd, stdin_data=None):
	pw_r, pw_w = pipe()
	pw_w = os.fdopen(pw_w, "w")
	cmdargs = [gpgcmd, "--quiet", "--batch", "--passphrase-fd", str(pw_r)] + args

	# close write end of passphrase pipe in child process
	proc = subprocess.Popen(cmdargs, stdout=subprocess.PIPE, stdin=subprocess.PIPE,
				close_fds=False, preexec_fn=pw_w.close)

	# parent doesn't use read end
	os.close(pw_r)

	# send passphrase to gpg child
	pw_w.write(passwd)
	# probably redundant, since we're just about to close it, but why not...
	pw_w.flush()
	pw_w.close()

	stdout_data, _ = proc.communicate(stdin_data)

	retval = proc.wait()
	if retval != 0:
		raise subprocess.CalledProcessError(retval, cmdargs)

	return stdout_data

def path_components(path):
	np = os.path.normpath(path)
	while len(np) > 0 and np[0] == os.sep:
		np = np[1:]
	return np.split(os.sep) if len(np) > 0 else []

default_constraints = "L12:C2:m2:N2:P2"

gen_constraints_desc = """
CONSTRAINTS is a colon-separated list of data constraints of the form TV.

T is a type indicator: L for length, C for capital letters, m for
lower-case letters, N for numerals (digits), and P for punctuation
characters.

V is the numeric value of of the constraint: for L (length) this
specifies the length of the generated data; for all others it provides
a minimum number of characters of that type, though as a special case
V=0 means the character type will be omitted.

The default constraint is %s, specifying a twelve-character
entry with at least two capital letters, at least two lower-case
letters, at least two digits, and at least two punctuation characters.
The user-provided constraint list (which may be empty) can selectively
override these constraints.

Stupid-site example: L8:C2:m2:N2:P0 for an 8-character purely
alphanumeric (but mixed-case) entry.""" % default_constraints

def constraints_to_dict(cstr):
	d = {}
	for c in cstr.split(":"):
		if c != "":
			d[c[0]] = int(c[1:])
	return d

uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
lowers = "abcdefghijklmnopqrstuvwxyz"
digits = "0123456789"
punctuation = "!@#$%^&*:._-=+"

def generate_data(constraints):
	cdict = constraints_to_dict(default_constraints)
	cdict.update(constraints_to_dict(constraints))
	s = ""
	for _ in range(0, cdict['C']):
		s += random.choice(uppers)
	for _ in range(0, cdict['m']):
		s += random.choice(lowers)
	for _ in range(0, cdict['N']):
		s += random.choice(digits)
	for _ in range(0, cdict['P']):
		s += random.choice(punctuation)

	padchars = ""
	if cdict['C'] > 0:
		padchars += uppers
	if cdict['m'] > 0:
		padchars += lowers
	if cdict['N'] > 0:
		padchars += digits
	if cdict['P'] > 0:
		padchars += punctuation

	# fill remaining space from pad character sets
	for _ in range(0, cdict['L']-len(s)):
		s += random.choice(padchars)

	l = list(s)
	random.shuffle(l)
	return ''.join(l[:cdict['L']])

def recursive_list(obj, pfx):
	t = fsobjtype(obj)
	if t == FILE or t == DIRECTORY:
		sys.stdout.write("%s\n" % pfx)
		if t == DIRECTORY:
			for n, o in obj.items():
				recursive_list(o, os.path.join(pfx, n))
	else:
		raise MistypedObject(pfx, obj)

class Directory(dict):
	def __init__(self, parent):
		if parent is None:
			parent = self
		else:
			assert type(parent) is Directory
		self._specials = {os.path.curdir: self, os.path.pardir: parent}
		self._dict = super(Directory, self)

	@classmethod
	def from_dict(cls, d, parent=None):
		newdir = cls(parent)
		for name, obj in d.items():
			if isinstance(obj, dict):
				obj = cls.from_dict(obj, newdir)
			newdir[name] = obj
		return newdir

	def __getitem__(self, k):
		if k in self._specials:
			return self._specials[k]
		else:
			return self._dict.__getitem__(k)

	def __contains__(self, k):
		return k in self._specials or self._dict.__contains__(k)

	def __setitem__(self, k, v):
		assert k not in self._specials
		self._dict.__setitem__(k, v)

	def __delitem__(self, k):
		assert k not in self._specials
		self._dict.__delitem__(k)

class JemfShell(CommandInterpreter):
	def __init__(self, jemf, args):
		self.fs = jemf
		self.args = args
		self.prompt = "jemf[%s]> " % self.fs.filename if sys.stdin.isatty() else ""
		CommandInterpreter.__init__(self)

	def do_EOF(self, args):
		"""EOF (^D): exit shell session."""
		if sys.stdin.isatty():
			sys.stdout.write('\n')
		return True

	def postcmd(self, stop, line):
		return stop

	def emptyline(self):
		return

	def default(self, line):
		errprint("Unrecognized command: %s" % line.split()[0])
		errprint("(see 'help')")

	def completedefault(self, orig_text, line, beg, end):
		try:
			if shlex.split(line[:end] + ".")[-1] != ".":
				text = shlex.split(line[:end])[-1]
			else:
				text = orig_text
		except ValueError:
			text = orig_text
		ppath, pfx = os.path.split(text)

		pdir = self.fs.lookup_path(ppath, noexc=True)
		if pdir is None:
			return []

		base = orig_text[:-len(pfx)]
		l = []
		for name in pdir:
			if name.startswith(pfx):
				l.append(base + name)

		if len(l) == 1 and l[0] == orig_text:
			obj = self.fs.lookup_path(text)
			suffix = os.sep if fsobjtype(obj) == DIRECTORY else " "
			return [orig_text + suffix]
		else:
			return l

	@classmethod
	def _add_cmd_handler(cls, cmd):
		def cmdfun(self, argstr):
			try:
				args = cmd.parser.parse_args(shlex.split(argstr))
			except UsageError as ue:
				if ue.args[0]:
					errprint(ue.args[0])
				return
			# merge in original self.args if not overridden
			for k,v in self.args.__dict__.items():
				if k not in args:
					setattr(args, k, v)
			try:
				cmd.action(self.fs, args)
			except UserError as ue:
				if ue.args[0]:
					errprint(ue.args[0])
		cmdfun.__doc__ = cmd.parser.format_help()
		setattr(cls, "do_%s" % cmd.name, cmdfun)

def mk_raise_usage_error(usage):
	usg = usage.strip()
	def func(msg):
		raise UsageError("%s\n%s" % (usg, msg.strip()))
	return func

def mk_path_arg(desc, opt=False):
	d = dict(metavar="PATH", help=desc)
	if opt:
		d["nargs"] = '?'
	return (("path",), d)

class Jemf(object):
	def __init__(self, filename, password):
		self.filename = filename
		self.password = password
		self.data = Directory(None)
		self.metadata = {}
		# to preserve any other stuff found in the file
		# (e.g. if it was last written out by a newer version)
		self.extra_sections = {}

	def _to_json(self):
		d = self.extra_sections.copy()
		d["data"] = self.data
		d["metadata"] = self.metadata
		return pretty_json_dump(d)

	def _from_json(self, s):
		jd = json.loads(s)
		self.metadata = jd.pop("metadata")
		self.data = Directory.from_dict(jd.pop("data"))
		self.extra_sections = jd

	@classmethod
	def load_from_path(cls, filename, password):
		fs = cls(filename, password)
		s = run_gpg(["-d", "--no-mdc-warning", filename], password)
		try:
			fs._from_json(s.decode("utf-8"))
		except KeyError:
			raise CorruptFS("data/metadata not found")
		return fs

	def write_out(self):
		self.metadata["last_modification_time"] = time.time()
		self.metadata["last_modification_host"] = socket.gethostbyaddr(socket.gethostname())[0]
		jemf_buf = str.encode(self._to_json(), "utf-8")

		# If filename is a symlink, do the new file write & rename in
		# the  directory in which the pointed-to file resides
		filename = os.path.realpath(self.filename)

		tmpfd, tmppath = tempfile.mkstemp(prefix=os.path.basename(filename),
						  dir=os.path.dirname(filename))

		output = run_gpg(["-c", "--yes", "-o", tmppath], self.password, jemf_buf)
		if output != b'':
			os.unlink(tmppath)
			internal_error("Unexpected output from gpg: %s\n" % output)

		os.fsync(tmpfd)
		os.close(tmpfd)

		os.rename(tmppath, filename)
		# FIXME: fsync directory? python stdlib doesn't seem to have opendir()...

	def _lookup_comps(self, comps, noexc=False):
		fsdir = self.data
		trail = os.sep
		for c in comps:
			try:
				fsdir = fsdir[c]
			except KeyError:
				if noexc:
					return None
				else:
					error("'%s' does not exist in '%s'" % (c, trail))
			trail = os.path.join(trail, c)
		return fsdir

	def lookup_path(self, path, noexc=False):
		return self._lookup_comps(path_components(path), noexc=noexc)

	def lookup_for_edit(self, path, should_exist, noexc=False):
		"""Lookup the parent of 'path', returning a tuple of it and the last
		component of 'path'."""
		comps = path_components(path)
		# special-case hack for looking up the root directory
		if len(comps) == 0:
			if should_exist is not None and not should_exist:
				error("'%s' already exists" % path)
			return (self.data, os.path.curdir)
		parentcomps = comps[:-1]
		tgtcomp = comps[-1]
		parent = self._lookup_comps(parentcomps, noexc=noexc)
		if fsobjtype(parent) != DIRECTORY:
			error("'%s' is not a directory" % os.path.join(*parentcomps))

		if should_exist is not None:
			if not should_exist and tgtcomp in parent:
				error("'%s' already exists" % path)
			elif should_exist and tgtcomp not in parent:
				error("'%s' does not exist" % path)

		return (parent, tgtcomp)

	# Methods that implement a command are indicated by having a "cmd_args" attribute

	_generate_arg = (("-g", "--generate"), dict(metavar="CONSTRAINTS", type=str,
						    help="auto-generate entry data"))
	_force_arg = (("-f", "--force"), dict(help="overwriting an existing file",
					      action="store_true"))

	def mkfs(self, args):
		"""initialize a new jemf FS"""
		self.data = Directory(None)
		self.metadata = {}
		self.extra_sections = {}
		self.write_out()
	mkfs.cmd_args = [_force_arg]

	def mkdir(self, args):
		"""create a new directory"""
		parent, newname = self.lookup_for_edit(args.path, should_exist=False)
		parent[newname] = Directory(parent)
		self.write_out()
	mkdir.cmd_args = [mk_path_arg("the directory to create")]

	def create(self, args):
		"""create a new file"""
		parent, newname = self.lookup_for_edit(args.path, should_exist=False)
		if args.generate is None:
			parent[newname] = confirmed_getpass("data for %s" % args.path)
		else:
			parent[newname] = generate_data(args.generate)
		self.write_out()
	create.cmd_args = [_generate_arg, mk_path_arg("the file to create")]
	create.parser_args = dict(epilog=gen_constraints_desc,
				  formatter_class=argparse.RawDescriptionHelpFormatter)

	def edit(self, args):
		"""edit an existing file"""
		parent, tgtname = self.lookup_for_edit(args.path, should_exist=True)
		if fsobjtype(parent[tgtname]) != FILE:
			error("'%s' is not a file" % args.path)

		if args.generate is None:
			parent[tgtname] = confirmed_getpass("new data for %s" % args.path)
		else:
			parent[tgtname] = generate_data(args.generate)
		self.write_out()
	edit.cmd_args = [_generate_arg, mk_path_arg("the file to edit")]
	edit.parser_args = dict(epilog=gen_constraints_desc,
				formatter_class=argparse.RawDescriptionHelpFormatter)

	def mv(self, args):
		"""move/rename a file or directory"""
		curparent, objname = self.lookup_for_edit(args.frompath, should_exist=True)
		obj = curparent[objname]
		topath = args.topath
		newparent, newobjname = self.lookup_for_edit(topath, should_exist=None)
		if newobjname in newparent and fsobjtype(newparent[newobjname]) == DIRECTORY:
			newparent = newparent[newobjname]
			newobjname = objname
			topath = os.path.join(args.topath, objname)

		p = newparent
		while p[".."] is not p:
			if p is obj:
				error("can't move '%s' inside itself" % args.frompath)
			p = p[".."]

		if newobjname in newparent:
			existing = newparent[newobjname]
			if not args.force:
				error("'%s' exists (user '-f' to overwrite)" % topath)
			elif fsobjtype(existing) == DIRECTORY and len(existing) > 0:
				error("'%s' is not empty" % topath)

		newparent[newobjname] = obj
		del curparent[objname]
		self.write_out()
	mv.cmd_args = [_force_arg,
		       (("frompath",), dict(metavar="FROM", help="current path/name")),
		       (("topath",), dict(metavar="TO", help="new path/name"))]

	def rm(self, args):
		"""delete a file or directory"""
		parent, tgtname = self.lookup_for_edit(args.path, should_exist=True)
		if args.recursive:
			del parent[tgtname]
		else:
			obj = parent[tgtname]
			if fsobjtype(obj) == DIRECTORY and len(obj) > 0:
				error("'%s' is not empty" % args.path)
			else:
				del parent[tgtname]
		self.write_out()
	rm.cmd_args = [(("-r", "--recursive"), dict(action="store_true")),
		       mk_path_arg("the file or directory to delete")]

	def cat(self, args):
		"""print a file to stdout"""
		item = self.lookup_path(args.path)
		t = fsobjtype(item)
		if t == DIRECTORY:
			error("'%s' is a directory" % args.path)
		elif t != FILE:
			raise MistypedObject(args.path, item)
		sys.stdout.write(item + '\n')
	cat.cmd_args = [mk_path_arg("the file to print")]

	def find(self, args):
		"""recursively list files and directories"""
		if args.path is None:
			recursive_list(self.data, os.sep)
		else:
			recursive_list(self.lookup_path(args.path), args.path)
	find.cmd_args = [mk_path_arg("starting directory (default: root)", opt=True)]

	def ls(self, args):
		"""list files and directories"""
		if args.path is not None:
			obj = self.lookup_path(args.path)
		else:
			obj = self.data

		if fsobjtype(obj) == FILE:
			sys.stdout.write(args.path + '\n')
		elif fsobjtype(obj) == DIRECTORY:
			for n, o in sorted(obj.items()):
				sys.stdout.write("%s%s\n" % (n, os.sep if fsobjtype(o) == DIRECTORY else ""))
		else:
			raise MistypedObject(args.path, obj)
	ls.cmd_args = [mk_path_arg("file or directory to list (default: root)", opt=True)]

	def dump(self, args):
		"""dump plaintext JSON"""
		if args.kind == "data":
			s = pretty_json_dump(self.data)
		elif args.kind == "metadata":
			s = pretty_json_dump(self.metadata)
		else:
			s = self._to_json()
		sys.stdout.write(s)
	dump.cmd_args = [(("-m", "--metadata"), dict(action="store_const", dest="kind",
						     const="metadata", help="dump only metadata")),
			 (("-d", "--data"), dict(action="store_const", dest="kind",
						 const="data", help="dump only data"))]

	def shell(self, args):
		"""start an interactive jemf shell"""
		sh = JemfShell(self, args)

		for _, cmd in self.commands.items():
			if cmd.name in ["shell", "mkfs"]:
				continue

			# get the "jemf" prefix out of the help message
			cmd.parser.prog = cmd.name

			# hack around argparse's inability to report
			# an error without exiting...
			cmd.parser.error = mk_raise_usage_error(cmd.parser.format_usage())

			sh._add_cmd_handler(cmd)

		sh.cmdloop()
	shell.cmd_args = []

	class Command(object):
		def __init__(self, action, cmdargs, **parser_kwargs):
			self.action = action
			self.name = self.action.__name__
			self.desc = self.action.__doc__
			self.cmdargs = cmdargs
			self.parser_kwargs = parser_kwargs

		def add_to(self, subparsers):
			self.parser = subparsers.add_parser(self.name, description=self.desc,
							    help=self.desc, **self.parser_kwargs)
			self.parser.set_defaults(action=self.action)
			for a in self.cmdargs:
				self.parser.add_argument(*a[0], **a[1])

	commands = {}

# plumb things together for subcommands...
for _, v in Jemf.__dict__.items():
	if hasattr(v, "cmd_args"):
		kw = v.parser_args if hasattr(v, "parser_args") else {}
		Jemf.commands[v.__name__] = Jemf.Command(v, v.cmd_args, **kw)

def open_jemf_fs(args):
	password = getpass.getpass("Enter password for %s: " % args.fsfile)
	return Jemf.load_from_path(args.fsfile, password)

def new_jemf_fs(args):
	if os.path.exists(args.fsfile) and not args.force:
		error("%s exists (use -f to force reinitialization)" % args.fsfile)
	password = confirmed_getpass("password for new jemf FS (%s)" % args.fsfile)
	return Jemf(args.fsfile, password)

if __name__ == "__main__":
	mainparser = argparse.ArgumentParser(description="a jeneric (?), encrypted mini-filesystem",
					     epilog="FS file can also be specified with the environment"
					     " variable JEMF_FSFILE")

	mainparser.add_argument("-f", "--fsfile", type=str, help="jemf FS file to use")

	subparsers = mainparser.add_subparsers(metavar="COMMAND", title=None)

	# sorted so --help output comes out consistently
	for _, cmd in sorted(Jemf.commands.items()):
		cmd.add_to(subparsers)

	args = mainparser.parse_args()

	if args.fsfile is None:
		for p in [os.getenv("JEMF_FSFILE"), find_fs()]:
			if p is not None:
				args.fsfile = p
				break

	if args.fsfile is None:
		if args.action is Jemf.mkfs:
			args.fsfile = default_fspaths[0]
		else:
			error("no jemf FS found or specified")

	try:
		# matching by __name__ here is kind of ugly...
		ctor = new_jemf_fs if args.action.__name__ == "mkfs" else open_jemf_fs
		args.action(ctor(args), args)

	except subprocess.CalledProcessError as cpe:
		cmdname = cpe.cmd[0] if type(cpe.cmd) is list else cpe.cmd.split()[0]
		errprint("%s exited with status %d" % (cmdname, cpe.returncode))
		exit(1)
	except UserError as ue:
		if ue.args[0]:
			errprint(ue.args[0])
		exit(1)
