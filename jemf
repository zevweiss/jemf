#!/usr/bin/python

# jemf: a jeneric (?), encrypted mini-filesystem
#
# (a command-line password manager).
#
# Stores data in a gpg-encrypted JSON file.

from __future__ import print_function

import sys
import argparse
import getpass
import subprocess
import json
import os
import os.path
import random
import socket
import time
import tempfile
import cmd
import shlex

try:
	import readline
	readline.set_completer_delims(" \t\n" + os.sep)
except ImportError:
	pass

default_fspaths = [os.path.expanduser(p) for p in ["~/.config/jemf", "~/.jemf"]]
gpgcmd = "gpg"

# compat
if hasattr(os, "pipe2"):
	pipe = lambda: os.pipe2(0)
else:
	pipe = os.pipe

class UserError(Exception):
	pass

class UsageError(UserError):
	pass

class InternalError(Exception):
	pass

class CorruptFS(Exception):
	pass

class MistypedObject(CorruptFS):
	def __init__(self, path, obj):
		msg = "Mistyped object '%s': %s" % (path, str(type(obj)))
		super(MistypedObject, self).__init__(msg)
		self.wrongtype = type(obj)
		self.path = path

def errprint(s):
	print(s, file=sys.stderr)

def error(msg):
	raise UserError("Error: %s" % msg)

def internal_error(msg):
	raise InternalError("Internal error: %s" % msg)

def confirmed_getpass(label):
	pass1 = getpass.getpass("Enter %s: " % label)
	pass2 = getpass.getpass("Confirm %s: " % label)
	if pass1 != pass2:
		error("input mismatch")
	else:
		return pass1

def find_fs():
	for p in default_fspaths:
		if os.path.exists(p):
			return p
	return None

UNKNOWN = 0
FILE = 1
DIRECTORY = 2
def fsobjtype(obj):
	if type(obj) == dict:
		return DIRECTORY
	elif type(obj) == str or type(obj) == unicode:
		return FILE
	else:
		return UNKNOWN

def pretty_json_dump(d):
	return json.dumps(d, sort_keys=True, indent=4, separators=(',', ': ')) + '\n'

def run_gpg(args, passwd, stdin_data=None):
	pw_r, pw_w = pipe()
	pw_w = os.fdopen(pw_w, "w")
	cmdargs = [gpgcmd, "--quiet", "--batch", "--passphrase-fd", str(pw_r)] + args

	# close write end of passphrase pipe in child process
	proc = subprocess.Popen(cmdargs, stdout=subprocess.PIPE, stdin=subprocess.PIPE,
				close_fds=False, preexec_fn=lambda: pw_w.close())

	# parent doesn't use read end
	os.close(pw_r)

	# send passphrase to gpg child
	pw_w.write(passwd)
	# probably redundant, since we're just about to close it, but why not...
	pw_w.flush()
	pw_w.close()

	stdout_data, _ = proc.communicate(stdin_data)

	retval = proc.wait()
	if retval != 0:
		raise subprocess.CalledProcessError(retval, cmdargs)

	return stdout_data

def load_jemf_fs(filename, passwd):
	s = run_gpg(["-d", "--no-mdc-warning", filename], passwd)
	return json.loads(s.decode("utf-8"))

def store_jemf_fs(fsd, filename, passwd):
	fsd["metadata"]["last_modification_time"] = time.time()
	fsd["metadata"]["last_modification_host"] = socket.gethostbyaddr(socket.gethostname())[0]
	jfs = str.encode(pretty_json_dump(fsd), "utf-8")

	# If filename is a symlink, do the new file write & rename in
	# the pointed-to directory
	filename = os.path.realpath(filename)

	tmpfd, tmppath = tempfile.mkstemp(prefix=os.path.basename(filename),
					  dir=os.path.dirname(filename))

	output = run_gpg(["-c", "--yes", "-o", tmppath], passwd, jfs)
	if output != b'':
		os.unlink(tmppath)
		internal_error("Unexpected output from gpg: %s\n" % output)

	os.fsync(tmpfd)
	os.close(tmpfd)

	os.rename(tmppath, filename)
	# FIXME: fsync directory? python stdlib doesn't seem to have opendir()...

def open_jemf_fs(path):
	passwd = getpass.getpass("Enter password for %s: " % path)
	return load_jemf_fs(path, passwd), passwd

def path_components(path):
	np = os.path.normpath(path)
	while len(np) > 0 and np[0] == os.sep:
		np = np[1:]
	np = "" if np == "." else np
	return np.split(os.sep) if len(np) > 0 else []

def lookup_comps(fsd, comps, noexc=False):
	fsdir = fsd["data"]
	trail = os.sep
	for c in comps:
		try:
			fsdir = fsdir[c]
		except KeyError:
			if noexc:
				return None
			else:
				error("'%s' does not exist in '%s'" % (c, trail))
		trail = os.path.join(trail, c)
	return fsdir

def lookup_path(fsd, path, noexc=False):
	return lookup_comps(fsd, path_components(path), noexc=noexc)

def lookup_for_edit(fsd, path, should_exist, noexc=False):
	"""Lookup the parent of 'path' in 'fsd', returning a tuple of it and
	the last component of 'path'."""
	comps = path_components(path)
	parentcomps = comps[:-1]
	tgtcomp = comps[-1]
	parent = lookup_comps(fsd, parentcomps, noexc=noexc)
	if fsobjtype(parent) != DIRECTORY:
		error("'%s' is not a directory" % os.path.join(*parentcomps))

	if should_exist is not None:
		if not should_exist and tgtcomp in parent:
			error("'%s' already exists" % path)
		elif should_exist and tgtcomp not in parent:
			error("'%s' does not exist" % path)

	return (parent, tgtcomp)

default_constraints = "L12:C2:m2:N2:P2"

gen_constraints_desc = """
CONSTRAINTS is a colon-separated list of data constraints of the form TV.

T is a type indicator: L for length, C for capital letters, m for
lower-case letters, N for numerals (digits), and P for punctuation
characters.

V is the numeric value of of the constraint: for L (length) this
specifies the length of the generated data; for all others it provides
a minimum number of characters of that type, though as a special case
V=0 means the character type will be omitted.

The default constraint is %s, specifying a twelve-character
entry with at least two capital letters, at least two lower-case
letters, at least two digits, and at least two punctuation characters.
The user-provided constraint list (which may be empty) can selectively
override these constraints.

Stupid-site example: L8:C2:m2:N2:P0 for an 8-character purely
alphanumeric (but mixed-case) entry.""" % default_constraints

def constraints_to_dict(cstr):
	d = {}
	for c in cstr.split(":"):
		if c != "":
			d[c[0]] = int(c[1:])
	return d

uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
lowers = "abcdefghijklmnopqrstuvwxyz"
digits = "0123456789"
punctuation = "!@#$%^&*:._-=+"

def generate_data(constraints):
	cdict = constraints_to_dict(default_constraints)
	cdict.update(constraints_to_dict(constraints))
	s = ""
	for _ in xrange(0, cdict['C']):
		s += random.choice(uppers)
	for _ in xrange(0, cdict['m']):
		s += random.choice(lowers)
	for _ in xrange(0, cdict['N']):
		s += random.choice(digits)
	for _ in xrange(0, cdict['P']):
		s += random.choice(punctuation)

	padchars = ""
	if cdict['C'] > 0:
		padchars += uppers
	if cdict['m'] > 0:
		padchars += lowers
	if cdict['N'] > 0:
		padchars += digits
	if cdict['P'] > 0:
		padchars += punctuation

	# fill remaining space from pad character sets
	for _ in xrange(0, cdict['L']-len(s)):
		s += random.choice(padchars)

	l = list(s)
	random.shuffle(l)
	return ''.join(l[:cdict['L']])

def mkfs(args, unused_fsd, unused_passwd):
	if os.path.exists(args.fsfile) and not args.force:
		error("%s exists (use -f to force reinitialization)" % args.fsfile)
	passwd = confirmed_getpass("password for new jemf FS (%s)" % args.fsfile)
	fsd = dict(metadata={}, data={})
	store_jemf_fs(fsd, args.fsfile, passwd)

def mkdir(args, fsd, passwd):
	parent, newname = lookup_for_edit(fsd, args.path, should_exist=False)
	parent[newname] = {}
	store_jemf_fs(fsd, args.fsfile, passwd)

def create(args, fsd, passwd):
	parent, newname = lookup_for_edit(fsd, args.path, should_exist=False)
	if args.generate is None:
		parent[newname] = confirmed_getpass("data for %s" % args.path)
	else:
		parent[newname] = generate_data(args.generate)
	store_jemf_fs(fsd, args.fsfile, passwd)

def edit(args, fsd, passwd):
	parent, tgtname = lookup_for_edit(fsd, args.path, should_exist=True)
	if fsobjtype(parent[tgtname]) != FILE:
		error("'%s' is not a file" % args.path)

	if args.generate is None:
		parent[tgtname] = confirmed_getpass("new data for %s" % args.path)
	else:
		parent[tgtname] = generate_data(args.generate)
	store_jemf_fs(fsd, args.fsfile, passwd)

def rm(args, fsd, passwd):
	parent, tgtname = lookup_for_edit(fsd, args.path, should_exist=True)
	if args.recursive:
		del parent[tgtname]
	else:
		obj = parent[tgtname]
		if fsobjtype(obj) == DIRECTORY and len(obj) > 0:
			error("'%s' is not empty" % args.path)
		else:
			del parent[tgtname]

	store_jemf_fs(fsd, args.fsfile, passwd)

def cat(args, fsd, unused_passwd):
	item = lookup_path(fsd, args.path)
	t = fsobjtype(item)
	if t == DIRECTORY:
		error("'%s' is a directory" % args.path)
	elif t != FILE:
		raise MistypedObject(args.path, item)
	sys.stdout.write(item + '\n')

def recursive_list(obj, pfx):
	t = fsobjtype(obj)
	if t == FILE or t == DIRECTORY:
		sys.stdout.write("%s\n" % pfx)
		if t == DIRECTORY:
			for n, o in obj.items():
				recursive_list(o, os.path.join(pfx, n))
	else:
		raise MistypedObject(pfx, obj)

def find(args, fsd, unused_passwd):
	if args.path is None:
		recursive_list(fsd["data"], "/")
	else:
		recursive_list(lookup_path(fsd, args.path), args.path)

def ls(args, fsd, unused_passwd):
	if args.path is not None:
		obj = lookup_path(fsd, args.path)
	else:
		obj = fsd["data"]

	if fsobjtype(obj) == FILE:
		sys.stdout.write(args.path + '\n')
	elif fsobjtype(obj) == DIRECTORY:
		for n, o in sorted(obj.items()):
			sys.stdout.write("%s%s\n" % (n, "/" if fsobjtype(o) == DIRECTORY else ""))
	else:
		raise MistypedObject(args.path, obj)

def dump(args, fsd, unused_passwd):
	if args.kind == "data":
		d = fsd["data"]
	elif args.kind == "metadata":
		d = fsd["metadata"]
	else:
		d = fsd
	sys.stdout.write(pretty_json_dump(d))

def mk_cmd_handler(orig_args, fsd, passwd, sc):
	def cmdfun(self, argstr):
		try:
			args = sc.parser.parse_args(shlex.split(argstr))
		except UsageError as ue:
			if ue.args[0]:
				errprint(ue.args[0])
			return
		# merge in orig_args if not overridden
		for k,v in orig_args.__dict__.items():
			if k not in args:
				setattr(args, k, v)
		try:
			sc.action(args, fsd, passwd)
		except UserError as ue:
			if ue.args[0]:
				errprint(ue.args[0])
	return cmdfun

def mk_raise_usage_error(usage):
	usg = usage.strip()
	def func(msg):
		raise UsageError("%s\n%s" % (usg, msg.strip()))
	return func

class JemfShell(cmd.Cmd):
	def __init__(self, args, fsd):
		self.prompt = "jemf[%s]> " % args.fsfile if sys.stdin.isatty() else ""
		self.fsd = fsd
		cmd.Cmd.__init__(self)

	def do_EOF(self, args):
		"""EOF (^D): exit shell session."""
		if sys.stdin.isatty():
			sys.stdout.write('\n')
		return True

	def postcmd(self, stop, line):
		return stop

	def emptyline(self):
		return

	def default(self, line):
		errprint("Unrecognized command: %s" % line.split()[0])
		errprint("(see 'help')")

	def completedefault(self, orig_text, line, beg, end):
		try:
			if shlex.split(line[:end] + ".")[-1] != ".":
				text = shlex.split(line[:end])[-1]
			else:
				text = orig_text
		except ValueError:
			text = orig_text
		ppath, pfx = os.path.split(text)

		pdir = lookup_path(self.fsd, ppath, noexc=True)
		if pdir is None:
			return []

		base = orig_text[:-len(pfx)]
		l = []
		for name in pdir:
			if name.startswith(pfx):
				l.append(base + name)

		if len(l) == 1 and l[0] == orig_text:
			obj = lookup_path(self.fsd, text)
			suffix = os.sep if fsobjtype(obj) == DIRECTORY else " "
			return [orig_text + suffix]
		else:
			return l

def shell(args, fsd, passwd):
	for sc in subcommands:
		if sc.name in ["shell", "mkfs"]:
			continue

		# get the "jemf" prefix out of the help message
		sc.parser.prog = sc.name

		# hack around argparse's inability to report
		# an error without exiting...
		sc.parser.error = mk_raise_usage_error(sc.parser.format_usage())

		cmdfun = mk_cmd_handler(args, fsd, passwd, sc)

		cmdfun.__doc__ = sc.parser.format_help()

		setattr(JemfShell, "do_%s" % sc.name, cmdfun)

	JemfShell(args, fsd).cmdloop()

class Subcommand(object):
	def __init__(self, action, desc, cmdargs, *parser_args, **parser_kwargs):
		self.action = action
		self.name = action.__name__
		self.desc = desc
		self.cmdargs = cmdargs
		self.parser_args = parser_args
		self.parser_kwargs = parser_kwargs

	def add_to(self, subparsers):
		self.parser = subparsers.add_parser(self.name, *self.parser_args,
						    description=self.desc, help=self.desc,
						    **self.parser_kwargs)
		self.parser.set_defaults(action=self.action)
		for a in self.cmdargs:
			self.parser.add_argument(*a[0], **a[1])

def mk_path_arg(desc, opt=False):
	d = dict(metavar="PATH", help=desc)
	if opt:
		d["nargs"] = '?'
	return (("path",), d)

generate_arg = (("-g", "--generate"), dict(metavar="CONSTRAINTS", type=str,
					   help="auto-generate entry data"))

subcommands = [
	Subcommand(mkfs, "initialize a jemf FS",
		   [(("-f", "--force"), dict(help="overwrite an existing file",
					     action="store_true"))]),
	Subcommand(mkdir, "create a new directory", [mk_path_arg("the directory to create")]),
	Subcommand(cat, "print a file to stdout", [mk_path_arg("the file to print")]),
	Subcommand(create, "create a new file",
		   [generate_arg, mk_path_arg("the file to create")],
		   epilog=gen_constraints_desc,
		   formatter_class=argparse.RawDescriptionHelpFormatter),
	Subcommand(edit, "edit an existing file",
		   [generate_arg, mk_path_arg("the file to edit")],
		   epilog=gen_constraints_desc,
		   formatter_class=argparse.RawDescriptionHelpFormatter),
	Subcommand(rm, "delete a file or directory",
		   [(("-r", "--recursive"), dict(action="store_true")),
		    mk_path_arg("the file or directory to delete")]),
	Subcommand(find, "recursively list files and directories",
		   [mk_path_arg("starting directory (default: root)", opt=True)]),
	Subcommand(ls, "list files and directories",
		   [mk_path_arg("file or directory to list (default: root)", opt=True)]),
	Subcommand(dump, "dump plaintext JSON",
		   [(("-m", "--metadata"), dict(action="store_const", dest="kind",
						const="metadata", help="dump only metadata")),
		    (("-d", "--data"), dict(action="store_const", dest="kind",
					    const="data", help="dump only data"))]),
	Subcommand(shell, "start an interactive jemf shell", []),
]

if __name__ == "__main__":
	mainparser = argparse.ArgumentParser(description="a jeneric (?), encrypted mini-filesystem",
					     epilog="FS file can also be specified with the environment"
					     " variable JEMF_FSFILE")

	mainparser.add_argument("-f", "--fsfile", type=str, help="jemf FS file to use")

	subparsers = mainparser.add_subparsers(metavar="COMMAND", title=None)

	for sc in subcommands:
		sc.add_to(subparsers)

	args = mainparser.parse_args()

	if args.fsfile is None:
		args.fsfile = os.getenv("JEMF_FSFILE")

	if args.fsfile is None or args.fsfile == "":
		args.fsfile = find_fs()

	try:
		if args.fsfile is None:
			if args.action != mkfs:
				error("no jemf FS found or specified")
			else:
				args.fsfile = default_fspaths[0]

		if args.action != mkfs:
			fsd, passwd = open_jemf_fs(args.fsfile)
		else:
			fsd, passwd = None, None
		args.action(args, fsd, passwd)

	except subprocess.CalledProcessError as cpe:
		cmdname = cpe.cmd[0] if type(cpe.cmd) is list else cpe.cmd.split()[0]
		errprint("%s exited with status %d" % (cmdname, cpe.returncode))
		exit(1)
	except UserError as ue:
		if ue.args[0]:
			errprint(ue.args[0])
		exit(1)
